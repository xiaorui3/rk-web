1.面向对象的编程思想
	面向过程，面向对象
2.语法的支撑
	描述类-----抽象的概念
	属性
		权限修饰符  [特征修饰符]  数据类型  属性名字[ = 值];
	*方法				main方法(不属于任何一个类)
		方法设计的问题，尤为重要
		参数列表0-n，返回值类型0-1

		底层执行原理，存储/调用(栈)
		基本数据类型和引用数据类型的参数传递问题

		方法重载overload
			一组方法，相同的方法名，不同的参数(个数，类型，顺序)
			便于调用者使用方便，记忆一个方法名，看似传递好多不同的参数

		动态参数列表(可变参数)
			public void test(数据类型... 变量名){}
			...类型固定，个数可变(0-n)
			底层相当于就是个数组
			可变参数的方法跟数组参数的方法，不能构成重载
			但是有区别，数组参数必须传递，可变参数可以不传递(0个)
			可变参数只能放在参数列表的末尾

	构造方法
		当作一个特殊的方法来理解
		特殊在于功能上(方法内部做的事情)，只能做一件事(固定的事，创建对象)
		构造方法目的只有一个，就是创建当前类的对象
		写法：权限修饰符 类名(){}
		从结构上来说构造方法没有返回值类型
		但是从执行上来看，构造方法肯定有返回值(对象)
		通过new关键字调用	new Person();
		构造方法也存在着方法重载的概念(构造方法重载)
		正常来说，每一个类都含有一个默认无参数的构造方法
		有些时候，我们想在构建对象的同时做点别的事情，默认的就不好用了
		我们通常会自己描述构造方法(会将默认无参数的那个覆盖)
		建议在描述新的构造方法时候，保留无参数的构造方法

		this关键字
			指代的是当前那个对象
			能调用什么？
				1.调用一般属性，和一般方法
				2.还可以调用构造方法
			能放在哪儿写？
				1.当前类成员的任何位置
				2.只能放在另外的一个构造方法里写，必须在第一行

	代码块
		将代码块理解为一个非常特殊的方法
		特殊在写法上
			没有权限修饰符，没有参数和返回值，连名字都没有
		因为代码块特殊到连方法名都没有啦，所以压根找不到
		代码块不用调用，在构造方法执行之前，自动调用
		构造方法每次执行都会自动调用一次代码块

	通过类创建对象，通过对象去使用上述的功能(调用属性，调用方法)
		默认执行一个代码块
		调用了构造方法----->对象

===================================================

编码题：：：：
	自己设计一个类，目的是用来当作容器使用的
	为什么：之前我们只有一个可以存储好多元素的容器-----数组
		特点：长度固定，不能频繁的追加新的元素，删除也有点问题
		ArrayBox		add  get  remove。。。。


===================================================

	一个类的设计						设计方法(参数，返回值)
		人类
			有名字，有年龄
			能吃饭，能学习
	--------------------------------
	类和类之间的关系(对象和对象的关系)		设计关系
		按照中文的说法，一共有六种
		按照代码的表现，一共有三种

		继承，泛化(实现)			A is-a B
		聚合，组合，包含			A has-a B
		依赖						A use-a B		(need)


	继承关系
		在Java中我们要求单继承
		指的是，一个类只能通过extends关键字继承一个父类
		反之一个父类，可以被多个子类继承
		如果我就想让一个类继承多个？？？
			可以利用传递继承的方式
			A->B	B->C
			a.a();	a.b();	a.c();


		A类(父类)，B类(子类)
			public class B extends A{}
		1.子类通过extends继承父类，继承之后
			可以调用父类中所有的属性和方法
				父类中的属性和方法的访问权限得是public和protected
				子类的范围内可以访问父类受保护的属性或方法
		2.子类可以添加自己独有的属性或方法
		3.虽然子类能继承父类的方法，发现有些继承过来的方法不能满足子类需要
			需要在子类中进行方法重写override
			执行的结果肯定是子类重写之后的那个方法

			方法重写，与父类方法一致		
				方法名字和方法参数类型必须一致，里面的执行逻辑不一样
				子类方法的权限修饰符要求大于等于父类的权限
				父类方法是static，子类的方法不存在重写这一说法
				父类方法是final，子类的方法不能重写
				父类方法是abstract，子类的方法必须重写(添加具体实现)
				子类方法的返回值类型要求小于等于父类
		4.构造方法能不能被继承呢？？？
			不算是继承
			执行子类构造方法创建对象之前
			默认调用父类的构造方法
			如果父类构造方法之前还有代码块，代码块也会执行

		5.super关键字
			this
			当前调用属性/方法时的那个对象
				调用普通的属性/方法，放在类成员的任意位置
				调用构造方法时候，只能放在另一个构造方法里，放在第一行

			super
			当前调用属性/方法是那个对象的"父亲对象"
			super也能调用属性/方法(父类的)
			放在子类成员的任意位置
			也能调用构造方法(父类的构造方法)，另一个构造方法里，第一行

			深入思考，总结：
				this/super，用来调用普通属性/方法，随便
					this都是放在本类中，super是写在子类中找父类
				this/super，都可以用来调用构造方法
					必须放在第一行
					this和super调用构造方法的时候，不能同时出现
				this和super不是不能同时出现，是调构造方法的时候不能


		this调用方法时候的那个对象？？？？？？
		画内存图
				
============================================
	A is-a B		A extends B			A implements B
		public class A extends B{}
		public class B{}

	A has-a B				(聚合，组合，包含)		关联关系
		public class A{		汽车+轮子
			private String name = new String("");
			private B b = new B();
		}
		public class B{}

	A use-a B					使用-动作-行为-方法
		public class A{					B b = new B();
			public void test(B b){		a.test(b);
				B b = new B();
			}
			pubic void test1(){}		我 用 电脑讲课
			public void test2(){}
		}
		public class B{}

	理论上在这以前都学完
	就可以做任务啦		方法-->类-->关系


编码题：：：：
1.	利用面向对象的思想，设计类和类的关系
		小汽车，车轮子(4个)
		人，电脑
2.	描述以下关系
		(农夫种大豆，长大，成熟了，给猪当饲料)
		猪(名字，品种，年龄，体重，长肉(方法-算法))
		农夫养猪	，当猪涨到某个体重的时候100斤
		屠夫杀猪

		机房，电脑，学生
		机房里面存储着电脑(一台，多台)
		学生进入机房，使用电脑(找到关着的电脑使用)
		电脑有个状态(开，关)

		搬家公司，卡车，家具
		搬家公司，接到订单，派一辆卡车去客户家
		到客户家，装家具(输入，输入，输入)
		卡车运输，到地方，卸货(输出，输出，输出)

============================================

	面向对象的高级部分(各种各样的特性)

	权限修饰符
		public共有的，公共的，当前工程中的任何位置被访问		任意
		protected受保护的，当前类的子类范围可以访问		子类 同包 本类
		默认不写										同包 本类
		private私有的									本类

		1.考虑权限修饰符能修饰什么东西？？？
			修饰类本身------->public  默认不写
				内部类(一个类放在了另一个类的里面，成员/局部)
				private这种修饰符是可以用来修饰成员内部类
			修饰类里面的成员(属性，方法，构造方法)
				四个权限修饰符都可以使用
		2.不同访问权限的修饰符，访问范围到底有何区别
		3.未来什么场景下需要用什么权限修饰符


	有了权限以后，深入讨论一个问题--------封装
		封装----好多代码(步骤/逻辑)包裹起来-----方法
		封装----写完的代码，形成一个工具类-----给好多人都能用(架构)
		封装----类中属性权限范围的控制
				私有属性+公有的两个方法(setXxx,getXxx)
				private int age;					boolean
				public void setAge(int age){}		setAge
				public int getAge(){}				isAge

	面向对象的三大特性(四)
		封装，继承，多态，抽象

===========================================
		volatile  transient  synchronized  native
	特征修饰符
		static
		final
		abstract------->抽象类，接口，多态

		14：00----17：00

		static----静态的
	1.修饰什么？
		修饰类成员(内部类)
		属性，方法，代码块
	2.修饰以后具备什么特点？
		修饰了以后，这个元素只有一份，全部类对象包括类本身共享
		静态元素在类加载的时候，就初始化啦(很早，在对象创建之前)
		静态元素存储在一个当前类对应的静态元素区域内(每一个类自己独有的)
		静态元素加载的时候，不用创建对象的，认为静态元素属于类
		因为静态元素不用创建对象就加载了，所以通过类名直接调用
		非静态成员可以访问静态成员的
		静态成员不能访问非静态成员的
		静态成员中是不能存在this或super关键字的

		深入思考一下，关于类的加载，初始化的问题
		类加载-----类信息(类模板)
		初始化-----执行(静态，代码块，构造方法)
	3.未来开发的时候，什么场景下我能用得上？？？
		唯一的一份，让所有对象共享
		有的时候，不想创建对象，我还想用----->		单例设计模式
		
===============================================

		final----最终的
	1.能修饰什么？	
		变量，属性，方法，类本身
	2.修饰以后有什么特点？
		变量----给一次赋值的机会，以后不能再改(基本类型-值，引用类型-地址)
		属性----与修饰变量类似，必须赋初识值
		方法----方法不让改？？？子类不能重写这个方法
		类------表示当前类不能被继承		用到的很多工具类底层
	3.应用场景？
		属性，不让动
		方法和类不让改				----->	静态常量(枚举)
























